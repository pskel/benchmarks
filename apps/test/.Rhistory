View(fail)
fail.diff = (fail$Exec_time_predicted-fail$Exec_time)/fail$Exec_time
fail.diff
fail.diff = (fail$Exec_time_predicted-fail$Exec_time)/fail$Exec_time * 100
fail.diff
fail$app
df=read.csv("quadro_syn_float_data.csv")
df$app = as.character(df$app)
df$pct_gpu = factor(df$pct_gpu)
df = df[,c("app", "ite","input","pct_gpu", "Exec_time", "BR_INS","BR_MSP","BR_TKN","FPO_CYC","FP_INS","INS_CYC","L2_DCM","L2_DCR","L2_LDM","L2_STM","L3_DCR","L3_TCM","LD_INS","REF_CYC","SR_INS","STL_ICY","achieved_occupancy","alu_fu_utilization","branch_efficiency","cf_fu_utilization","dram_utilization","gld_efficiency","gld_transactions_per_request","gst_efficiency","gst_transactions_per_request","inst_per_warp","ipc","issue_slot_utilization","issued_ipc","l1_cache_global_hit_rate","l1_cache_local_hit_rate","l1_shared_utilization","l2_l1_read_hit_rate","l2_utilization","ldst_fu_utilization","sm_efficiency","stall_data_request","stall_exec_dependency","stall_inst_fetch","stall_sync","stall_other","warp_execution_efficiency")]
colnames(df)[which(names(df) == "l2_l1_read_hit_rate")] <- "GPU_L2_TCH"
colnames(df)[which(names(df) == "l1_cache_global_hit_rate")] <- "GPU_L1_TCH"
colnames(df)[which(names(df) == "sm_efficiency")] <- "GPU_SME"
colnames(df)[which(names(df) == "ite")] <- "ITERATIONS"
colnames(df)[which(names(df) == "L2_DCM")] <- "CPU_L2_DCM"
colnames(df)[which(names(df) == "L2_LDM")] <- "CPU_L2_LDM"
colnames(df)[which(names(df) == "L3_TCM")] <- "CPU_L3_TCM"
fit.float2 <- rpart(pct_gpu ~ ITERATIONS + CPU_L2_DCM + CPU_L3_TCM + 	GPU_L1_TCH + GPU_L2_TCH,method="class", data=df,control=rpart.control(minsplit=20,minbucket=8))
library(rpart)
library(rpart.plot)
library(caret)
library(randomForest)
library(sperrorest)
library(party)
library(rattle)					# Fancy tree plot
library(RColorBrewer)		# Color selection for fancy tree plot
library(party)					# Alternative decision tree algorithm
library(partykit)				# Convert rpart object to BinaryTree
library(caret)
fit.float2 <- rpart(pct_gpu ~ ITERATIONS + CPU_L2_DCM + CPU_L3_TCM + 	GPU_L1_TCH + GPU_L2_TCH,method="class", data=df,control=rpart.control(minsplit=20,minbucket=8))
rpart.plot(fit.float2,main=paste("Partitioning decision tree",collapse=" "),cex = 0.6,varlen=30,fallen.leaves = TRUE)
prp(fit.float2,type=0,extra=102,digits=4,under=FALSE,faclen=0,varlen=0,split.border.col=0,fallen.leaves = TRUE,leaf.round=1,ycompress = TRUE,compress=TRUE,xcompact=TRUE,xcompact.ratio=0.5,ycompact=FALSE,nn=FALSE,split.font=1,branch=1,tweak=0.95,cex=0.65,branch.tweak=1.1,split.cex=1,xflip=TRUE,left=TRUE,nn.cex=0.7)
predictions = predict(fit.float2,apps,type="class")
accuracy.global = sum(predictions==apps$pct_gpu)/nrow(apps)
colnames(apps)[which(names(apps) == "l2_l1_read_hit_rate")] <- "GPU_L2_TCH"
colnames(apps)[which(names(apps) == "l1_cache_global_hit_rate")] <- "GPU_L1_TCH"
colnames(apps)[which(names(apps) == "sm_efficiency")] <- "GPU_SME"
colnames(apps)[which(names(apps) == "ITERATIONS")] <- "ite"
colnames(apps)[which(names(apps) == "L2_LDM")] <- "CPU_L2_LDM"
colnames(apps)[which(names(apps) == "L3_TCM")] <- "CPU_L3_TCM"
predictions = predict(fit.float2,apps,type="class")
accuracy.global = sum(predictions==apps$pct_gpu)/nrow(apps)
colnames(apps)[which(names(apps) == "l2_l1_read_hit_rate")] <- "GPU_L2_TCH"
colnames(apps)[which(names(apps) == "l1_cache_global_hit_rate")] <- "GPU_L1_TCH"
colnames(apps)[which(names(apps) == "sm_efficiency")] <- "GPU_SME"
colnames(apps)[which(names(apps) == "ite")] <- "ITERATIONS"
colnames(apps)[which(names(apps) == "L2_LDM")] <- "CPU_L2_LDM"
colnames(apps)[which(names(apps) == "L3_TCM")] <- "CPU_L3_TCM"
predictions = predict(fit.float2,apps,type="class")
accuracy.global = sum(predictions==apps$pct_gpu)/nrow(apps)
colnames(apps)
apps=read.csv("quadro_app_data.csv")
colnames(apps)
colnames(df)[which(names(df) == "l2_l1_read_hit_rate")] <- "GPU_L2_TCH"
colnames(df)[which(names(df) == "l1_cache_global_hit_rate")] <- "GPU_L1_TCH"
colnames(df)[which(names(df) == "sm_efficiency")] <- "GPU_SME"
colnames(df)[which(names(df) == "ite")] <- "ITERATIONS"
colnames(df)[which(names(df) == "L2_DCM")] <- "CPU_L2_DCM"
colnames(df)[which(names(df) == "L2_LDM")] <- "CPU_L2_LDM"
colnames(df)[which(names(df) == "L3_TCM")] <- "CPU_L3_TCM"
predictions = predict(fit.float2,apps,type="class")
accuracy.global = sum(predictions==apps$pct_gpu)/nrow(apps)
colnames(apps)[which(names(apps) == "l2_l1_read_hit_rate")] <- "GPU_L2_TCH"
colnames(apps)[which(names(apps) == "l1_cache_global_hit_rate")] <- "GPU_L1_TCH"
colnames(apps)[which(names(apps) == "sm_efficiency")] <- "GPU_SME"
colnames(apps)[which(names(apps) == "ite")] <- "ITERATIONS"
colnames(apps)[which(names(apps) == "L2_LDM")] <- "CPU_L2_LDM"
colnames(apps)[which(names(apps) == "L3_TCM")] <- "CPU_L3_TCM"
apps$ITERATIONS
predictions = predict(fit.float2,apps,type="class")
accuracy.global = sum(predictions==apps$pct_gpu)/nrow(apps)
colnames(apps)[which(names(apps) == "L2_DCM")] <- "CPU_L2_DCM"
predictions = predict(fit.float2,apps,type="class")
accuracy.global = sum(predictions==apps$pct_gpu)/nrow(apps)
predictions
table(predictions,apps$pct_gpu)
predictions,apps$pct_gpu
c(predictions,apps$pct_gpu)
print(predictions,apps$pct_gpu)
subset(predictions,apps$pct_gpu)
apps$new_predict = predictions
apps[,c("app","input","pct_gpu","new_predict")]
fit.float3 <- rpart(pct_gpu ~ ITERATIONS + CPU_L2_DCM + CPU_L3_TCM + 	GPU_L1_TCH + GPU_L2_TCH,method="class", data=df,control=rpart.control(minsplit=20,minbucket=8),parms=list(split="information"))
prp(fit.float3,type=0,extra=102,digits=4,under=FALSE,faclen=0,varlen=0,split.border.col=0,fallen.leaves = TRUE,leaf.round=1,ycompress = TRUE,compress=TRUE,xcompact=TRUE,xcompact.ratio=0.5,ycompact=FALSE,nn=FALSE,split.font=1,branch=1,tweak=0.95,cex=0.65,branch.tweak=1.1,split.cex=1,xflip=TRUE,left=TRUE,nn.cex=0.7)
predictions = predict(fit.float3,apps,type="class")
accuracy.global = sum(predictions==apps$pct_gpu)/nrow(apps)
accuracy.global
predictions = predict(fit.float3,apps,type="class")
accuracy.global = sum(predictions==apps$pct_gpu)/nrow(apps)
fit.float3 <- rpart(pct_gpu ~ ITERATIONS + CPU_L2_DCM + CPU_L3_TCM + 	GPU_L1_TCH + GPU_L2_TCH,method="class", data=df,parms=list(split="information"))
fit.float3 <- rpart(pct_gpu ~ ITERATIONS + CPU_L2_DCM + CPU_L3_TCM + 	GPU_L1_TCH + GPU_L2_TCH,method="class", data=df,parms=list(split="information"))
predictions = predict(fit.float3,apps,type="class")
accuracy = sum(predictions==apps$pct_gpu)/nrow(apps)
print(accuracy)
fit.float3 <- rpart(pct_gpu ~ ITERATIONS + CPU_L2_DCM + CPU_L3_TCM + 	GPU_L1_TCH + GPU_L2_TCH+ GPU_SME,method="class", data=df,parms=list(split="information"))
predictions = predict(fit.float3,apps,type="class")
accuracy = sum(predictions==apps$pct_gpu)/nrow(apps)
print(accuracy)
fit.float3 <- rpart(pct_gpu ~ ITERATIONS + CPU_L2_DCM + CPU_L3_TCM + 	GPU_L1_TCH + GPU_L2_TCH+ GPU_SME,method="class", data=df,parms=list(split="gini"))
predictions = predict(fit.float3,apps,type="class")
accuracy = sum(predictions==apps$pct_gpu)/nrow(apps)
print(accuracy)
fit.float3 <- rpart(pct_gpu ~ ITERATIONS + CPU_L2_DCM + CPU_L3_TCM + 	GPU_L1_TCH + GPU_L2_TCH+ GPU_SME,method="class", data=df,parms=list(split="information"))
predictions = predict(fit.float3,apps,type="class")
accuracy = sum(predictions==apps$pct_gpu)/nrow(apps)
print(accuracy)
fit.float3 <- rpart(pct_gpu ~ ITERATIONS + CPU_L2_DCM + CPU_L3_TCM + 	GPU_L1_TCH + GPU_L2_TCH+ GPU_SME,method="class", data=df,control=rpart.control(minsplit=20,minbucket=8),parms=list(split="information"))
predictions = predict(fit.float3,apps,type="class")
accuracy = sum(predictions==apps$pct_gpu)/nrow(apps)
print(accuracy)
fit.float3 <- rpart(pct_gpu ~ ITERATIONS + CPU_L2_DCM + CPU_L3_TCM + 	GPU_L1_TCH + GPU_L2_TCH+ GPU_SME,method="class", data=df,control=rpart.control(minsplit=20,minbucket=8),parms=list(split="gini"))
predictions = predict(fit.float3,apps,type="class")
accuracy = sum(predictions==apps$pct_gpu)/nrow(apps)
print(accuracy)
prp(fit.float3,type=0,extra=102,digits=4,under=FALSE,faclen=0,varlen=0,split.border.col=0,fallen.leaves = TRUE,leaf.round=1,ycompress = TRUE,compress=TRUE,xcompact=TRUE,xcompact.ratio=0.5,ycompact=FALSE,nn=FALSE,split.font=1,branch=1,tweak=0.95,cex=0.65,branch.tweak=1.1,split.cex=1,xflip=TRUE,left=TRUE,nn.cex=0.7)
apps = read.csv('quadro_app_data_predicted_speedup.csv')
apps.error = apps[which(apps$ite>1),]
#210 samples
#129 samples corrected predicted
#81 samples incorrected predicted
#23 of 81 incorrected predicted samples present suboptimal speedup
error.index <- which(apps.error$pct_gpu_predicted != apps.error$pct_gpu)
apps.error = apps.error[error.index,]
suboptimal <- which((apps.error$Exec_time_predicted - apps.error$Exec_time_cpu) < 0 & (apps.error$Exec_time_predicted - apps.error$Exec_time_gpu) < 0)
apps.suboptimal = apps.error[suboptimal,]
fail = apps.error[-suboptimal,]
fail.cpu = fail[which(fail$Exec_time_cpu < fail$Exec_time_predicted),]
fail.gpu = fail[which(fail$Exec_time_gpu < fail$Exec_time_predicted),]
fail.diff = (fail$Exec_time_predicted-fail$Exec_time)/fail$Exec_time * 100
fail.diff
fail$app
fail$input
fail[,c("app","input")]
fail[,c("app","input","ite")]
fail$diff = (fail$Exec_time_predicted-fail$Exec_time)/fail$Exec_time * 100
fail[,c("app","input","ite","diff")]
fail[,c("app","input","ite","Exec_time_predicted","Exec_time","diff")]
setwd("~/Dropbox/IC/svn/pskel/code/src/ml")
options(digits = 2, width = 100)
df=read.csv("quadro_syn_float_data.csv")
View(df)
set.seed(100)
parti = partition.cv.strat(df,strat='pct_gpu',nfold = 2)
library(sperrorest)
install.packages("library(sperrorest)")
install.packages("library(sperrorest)")
install.packages("~/sperrorest_0.2-1.tar.gz", repos = NULL, type = "source")
install.packages("sperrorest")
A = c(5,15,-30,10,-5,40,10)
max = A[0]
max_start = 0
max_end = 0
S = A[0]
T = 0
for i in 1:length(A){
#S = max { S + A[i], A[i] )
if ( S > 0)
S = S + A[i];
}
else{
S = A[i];
T = i;
}
if ( S > max){
max_start = T;
max_end = i;
max = S;
}
}
print(max_start,max_end)
A = c(5,15,-30,10,-5,40,10)
max = A[0]
max_start = 0
max_end = 0
S = A[0]
T = 0
for (i in 1:length(A)){
#S = max { S + A[i], A[i] )
if ( S > 0)
S = S + A[i];
}
else{
S = A[i];
T = i;
}
if ( S > max){
max_start = T;
max_end = i;
max = S;
}
}
print(max_start,max_end)
A = c(5,15,-30,10,-5,40,10)
max = A[0]
max_start = 0
max_end = 0
S = A[0]
T = 0
for (i in 1:length(A)){
#S = max { S + A[i], A[i] )
if ( S > 0){
S = S + A[i];
}
else{
S = A[i];
T = i;
}
if ( S > max){
max_start = T;
max_end = i;
max = S;
}
}
print(max_start,max_end)
A = c(5,15,-30,10,-5,40,10)
A = c(5,15,-30,10,-5,40,10)
max = A[1]
max_start = 1
max_end = 1
S = A[1]
T = 0
for (i in 2:length(A)){
#S = max { S + A[i], A[i] )
if ( S > 0){
S = S + A[i];
}
else{
S = A[i];
T = i;
}
if ( S > max){
max_start = T;
max_end = i;
max = S;
}
}
print(max_start,max_end)
A = c(5,15,-30,10,-5,40,10)
max = A[1]
max_start = 1
max_end = 1
S = A[1]
T = 0
for (i in 2:length(A)){
#S = max { S + A[i], A[i] )
if ( S > 0){
S = S + A[i];
}
else{
S = A[i];
T = i;
}
if ( S > max){
max_start = T;
max_end = i;
max = S;
}
}
print(c(max_start,max_end))
apps = read.csv('apps_predicted.csv')
apps$app = as.character(apps$app)
setwd("~/github/benchmarks/apps/test")
apps = read.csv('apps_predicted.csv')
apps = read.csv('app_predicted.csv')
for(j in c('cloudsim','convolution','fast','gol','jacobi')){
#for(i in c(24000)){
x <- apps[which(apps$app == j & apps$ite >= 1),c("speedup_cpu")]
x <- c(x,exp(mean(log(x[-1])))) #geometric mean
y <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_gpu")]
y <- c(y,exp(mean(log(y[-1])))) #geometric mean
w <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_awt")]
w <- c(w,exp(mean(log(w[-1])))) #geometric mean
z <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_oracle")]
z <- c(z,exp(mean(log(z[-1])))) #geometric mean
# create a two row matrix with x and y
height <- rbind(y,w,z)
#setEPS()
#postscript(paste(c(j,"_",i,"2.eps"),collapse=""))
#xlab = "# of iterations",ylab = "Speedup over single core",legend = c("CPU only","GPU only","Predictive model","Oracle"),args.legend = list(x="top",horiz=FALSE,inset=c(0,-0.1),ncol=2,cex=1.5),cex.axis=1.3,cex.names=1.2,cex.lab=1.5,mgp=c(2.8,1,0)
xx <- barplot(height, beside = TRUE,ylim = c(0, 20), names.arg = c(1,10,20,30,40,50,60,"gmean"))
#text(x = xx, y=height[x][], label=round(height[x],1), pos=3, col="black", font=2, cex=1.1)
#dev.off()
#}
}
par(xpd=TRUE,cex.lab=1.5)
for(j in c('cloudsim','convolution','fast','gol','jacobi')){
#for(i in c(24000)){
x <- apps[which(apps$app == j & apps$ite >= 1),c("speedup_cpu")]
x <- c(x,exp(mean(log(x[-1])))) #geometric mean
y <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_gpu")]
y <- c(y,exp(mean(log(y[-1])))) #geometric mean
w <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_awt")]
w <- c(w,exp(mean(log(w[-1])))) #geometric mean
z <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_oracle")]
z <- c(z,exp(mean(log(z[-1])))) #geometric mean
# create a two row matrix with x and y
height <- rbind(y,w,z)
#setEPS()
#postscript(paste(c(j,"_",i,"2.eps"),collapse=""))
xlab = "# of iterations",ylab = "Speedup over single core",legend = c("CPU only","GPU only","Predictive model","Oracle"),args.legend = list(x="top",horiz=FALSE,inset=c(0,-0.1),ncol=2,cex=1.5),cex.axis=1.3,cex.names=1.2,cex.lab=1.5,mgp=c(2.8,1,0)
xx <- barplot(height, beside = TRUE,ylim = c(0, 20), names.arg = c(1,10,20,30,40,50,60,"gmean"))
text(x = xx, y=height[x][], label=round(height[x],1), pos=3, col="black", font=2, cex=1.1)
#dev.off()
#}
}
apps$app
apps[which(apps$app == j & apps$ite >= 1),c("speedup_cpu")]
for(j in c('cloudsim','convolution','fast','gol','jacobi')){
#for(i in c(24000)){
x <- apps[which(apps$app == j & apps$ite >= 1),c("speedup_cpu")]
x <- c(x,exp(mean(log(x[-1])))) #geometric mean
y <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_gpu")]
y <- c(y,exp(mean(log(y[-1])))) #geometric mean
w <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_awt")]
w <- c(w,exp(mean(log(w[-1])))) #geometric mean
z <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_oracle")]
z <- c(z,exp(mean(log(z[-1])))) #geometric mean
# create a two row matrix with x and y
height <- rbind(y,w,z)
#setEPS()
#postscript(paste(c(j,"_",i,"2.eps"),collapse=""))
xlab = "# of iterations",ylab = "Speedup over single core",legend = c("CPU only","GPU only","Predictive model","Oracle"),args.legend = list(x="top",horiz=FALSE,inset=c(0,-0.1),ncol=2,cex=1.5),cex.axis=1.3,cex.names=1.2,cex.lab=1.5,mgp=c(2.8,1,0)
xx <- barplot(height, beside = TRUE,ylim = c(0, 20), names.arg = c(1,10,20,30,40,50,60,"gmean"))
text(x = xx, y=height[x][], label=round(height[x],1), pos=3, col="black", font=2, cex=1.1)
#dev.off()
#}
}
x <- apps[which(apps$app == j & apps$ite >= 1),c("speedup_cpu")]
x <- c(x,exp(mean(log(x[-1])))) #geometric mean
y <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_gpu")]
y <- c(y,exp(mean(log(y[-1])))) #geometric mean
w <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_awt")]
w <- c(w,exp(mean(log(w[-1])))) #geometric mean
z <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_oracle")]
z <- c(z,exp(mean(log(z[-1])))) #geometric mean
# create a two row matrix with x and y
height <- rbind(y,w,z)
#setEPS()
#postscript(paste(c(j,"_",i,"2.eps"),collapse=""))
xlab = "# of iterations",ylab = "Speedup over single core",legend = c("CPU only","GPU only","Predictive model","Oracle"),args.legend = list(x="top",horiz=FALSE,inset=c(0,-0.1),ncol=2,cex=1.5),cex.axis=1.3,cex.names=1.2,cex.lab=1.5,mgp=c(2.8,1,0)
xx <- barplot(height, beside = TRUE,ylim = c(0, 20), names.arg = c(1,10,20,30,40,50,60,"gmean"))
text(x = xx, y=height[x][], label=round(height[x],1), pos=3, col="black", font=2, cex=1.1)
xx <- barplot(height, beside = TRUE,ylim = c(0, 20), names.arg = c(1,10,20,30,40,50,60,"gmean"))
xx <- barplot(height, beside = TRUE,ylim = c(0, 20), names.arg = c(10,20,30,40,50,60,"gmean"))
par(xpd=TRUE,cex.lab=1.5)
for(j in c('cloudsim','convolution','fast','gol','jacobi')){
#for(i in c(24000)){
x <- apps[which(apps$app == j & apps$ite >= 1),c("speedup_cpu")]
x <- c(x,exp(mean(log(x[-1])))) #geometric mean
y <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_gpu")]
y <- c(y,exp(mean(log(y[-1])))) #geometric mean
w <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_awt")]
w <- c(w,exp(mean(log(w[-1])))) #geometric mean
z <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_oracle")]
z <- c(z,exp(mean(log(z[-1])))) #geometric mean
# create a two row matrix with x and y
height <- rbind(y,w,z)
#setEPS()
#postscript(paste(c(j,"_",i,"2.eps"),collapse=""))
#xlab = "# of iterations",ylab = "Speedup over single core",legend = c("CPU only","GPU only","Predictive model","Oracle"),args.legend = list(x="top",horiz=FALSE,inset=c(0,-0.1),ncol=2,cex=1.5),cex.axis=1.3,cex.names=1.2,cex.lab=1.5,mgp=c(2.8,1,0)
xx <- barplot(height, beside = TRUE,ylim = c(0, 20), names.arg = c(1,10,20,30,40,50,60,"gmean"))
text(x = xx, y=height[x][], label=round(height[x],1), pos=3, col="black", font=2, cex=1.1)
#dev.off()
#}
}
j="convolution"
x <- c(x,exp(mean(log(x[-1])))) #geometric mean
y <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_gpu")]
y <- c(y,exp(mean(log(y[-1])))) #geometric mean
w <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_awt")]
w <- c(w,exp(mean(log(w[-1])))) #geometric mean
z <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_oracle")]
z <- c(z,exp(mean(log(z[-1])))) #geometric mean
# create a two row matrix with x and y
height <- rbind(y,w,z)
#setEPS()
#postscript(paste(c(j,"_",i,"2.eps"),collapse=""))
#xlab = "# of iterations",ylab = "Speedup over single core",legend = c("CPU only","GPU only","Predictive model","Oracle"),args.legend = list(x="top",horiz=FALSE,inset=c(0,-0.1),ncol=2,cex=1.5),cex.axis=1.3,cex.names=1.2,cex.lab=1.5,mgp=c(2.8,1,0)
xx <- barplot(height, beside = TRUE,ylim = c(0, 20), names.arg = c(1,10,20,30,40,50,60,"gmean"))
text(x = xx, y=height[x][], label=round(height[x],1), pos=3, col="black", font=2, cex=1.1)
#dev.off()
x <- apps[which(apps$app == j & apps$ite >= 1),c("speedup_cpu")]
x <- c(x,exp(mean(log(x[-1])))) #geometric mean
y <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_gpu")]
y <- c(y,exp(mean(log(y[-1])))) #geometric mean
w <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_awt")]
w <- c(w,exp(mean(log(w[-1])))) #geometric mean
z <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_oracle")]
z <- c(z,exp(mean(log(z[-1])))) #geometric mean
# create a two row matrix with x and y
height <- rbind(y,w,z)
#setEPS()
#postscript(paste(c(j,"_",i,"2.eps"),collapse=""))
#xlab = "# of iterations",ylab = "Speedup over single core",legend = c("CPU only","GPU only","Predictive model","Oracle"),args.legend = list(x="top",horiz=FALSE,inset=c(0,-0.1),ncol=2,cex=1.5),cex.axis=1.3,cex.names=1.2,cex.lab=1.5,mgp=c(2.8,1,0)
xx <- barplot(height, beside = TRUE,ylim = c(0, 20), names.arg = c(10,20,30,40,50,60,"gmean"))
text(x = xx, y=height[x][], label=round(height[x],1), pos=3, col="black", font=2, cex=1.1)
#dev.off()
x <- apps[which(apps$app == j & apps$ite >= 1),c("speedup_cpu")]
x <- c(x,exp(mean(log(x[-1])))) #geometric mean
y <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_gpu")]
y <- c(y,exp(mean(log(y[-1])))) #geometric mean
w <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_awt")]
w <- c(w,exp(mean(log(w[-1])))) #geometric mean
z <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_oracle")]
z <- c(z,exp(mean(log(z[-1])))) #geometric mean
# create a two row matrix with x and y
height <- rbind(y,w,z)
#setEPS()
#postscript(paste(c(j,"_",i,"2.eps"),collapse=""))
#xlab = "# of iterations",ylab = "Speedup over single core",legend = c("CPU only","GPU only","Predictive model","Oracle"),args.legend = list(x="top",horiz=FALSE,inset=c(0,-0.1),ncol=2,cex=1.5),cex.axis=1.3,cex.names=1.2,cex.lab=1.5,mgp=c(2.8,1,0)
xx <- barplot(height, beside = TRUE,ylim = c(0, 20), names.arg = c(10,20,30,40,50,60,"gmean"))
text(x = xx, y=height[x][], label=round(height[x],1), pos=3, col="black", font=2, cex=1.1)
#dev.off()
x <- apps[which(apps$app == j & apps$ite >= 1),c("speedup_cpu")]
x <- c(x,exp(mean(log(x[-1])))) #geometric mean
y <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_gpu")]
y <- c(y,exp(mean(log(y[-1])))) #geometric mean
w <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_awt")]
w <- c(w,exp(mean(log(w[-1])))) #geometric mean
z <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_oracle")]
z <- c(z,exp(mean(log(z[-1])))) #geometric mean
# create a two row matrix with x and y
height <- rbind(y,w,z)
#setEPS()
#postscript(paste(c(j,"_",i,"2.eps"),collapse=""))
#xlab = "# of iterations",ylab = "Speedup over single core",legend = c("CPU only","GPU only","Predictive model","Oracle"),args.legend = list(x="top",horiz=FALSE,inset=c(0,-0.1),ncol=2,cex=1.5),cex.axis=1.3,cex.names=1.2,cex.lab=1.5,mgp=c(2.8,1,0)
xx <- barplot(height, beside = TRUE,ylim = c(0, 20), names.arg = c(10,20,30,40,50,60,"gmean"))
text(x = xx, y=height[x][], label=round(height[x],1), pos=3, col="black", font=2, cex=1.1)
#dev.off()
par(xpd=TRUE,cex.lab=1.5)
for(j in c('cloudsim','convolution','fast','gol','jacobi')){
#for(i in c(24000)){
x <- apps[which(apps$app == j & apps$ite >= 1),c("speedup_cpu")]
x <- c(x,exp(mean(log(x[-1])))) #geometric mean
y <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_gpu")]
y <- c(y,exp(mean(log(y[-1])))) #geometric mean
w <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_awt")]
w <- c(w,exp(mean(log(w[-1])))) #geometric mean
z <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_oracle")]
z <- c(z,exp(mean(log(z[-1])))) #geometric mean
# create a two row matrix with x and y
height <- rbind(y,w,z)
#setEPS()
#postscript(paste(c(j,"_",i,"2.eps"),collapse=""))
#xlab = "# of iterations",ylab = "Speedup over single core",legend = c("CPU only","GPU only","Predictive model","Oracle"),args.legend = list(x="top",horiz=FALSE,inset=c(0,-0.1),ncol=2,cex=1.5),cex.axis=1.3,cex.names=1.2,cex.lab=1.5,mgp=c(2.8,1,0)
xx <- barplot(height, beside = TRUE,ylim = c(0, 20), names.arg = c(10,20,30,40,50,60,"gmean"))
#text(x = xx, y=height[x][], label=round(height[x],1), pos=3, col="black", font=2, cex=1.1)
#dev.off()
#}
}
x <- apps[which(apps$app == j & apps$ite >= 1),c("speedup_cpu")]
x <- c(x,exp(mean(log(x[-1])))) #geometric mean
y <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_gpu")]
y <- c(y,exp(mean(log(y[-1])))) #geometric mean
w <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_awt")]
w <- c(w,exp(mean(log(w[-1])))) #geometric mean
z <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_oracle")]
z <- c(z,exp(mean(log(z[-1])))) #geometric mean
# create a two row matrix with x and y
height <- rbind(x,y,w,z)
#setEPS()
#postscript(paste(c(j,"_",i,"2.eps"),collapse=""))
#xlab = "# of iterations",ylab = "Speedup over single core",legend = c("CPU only","GPU only","Predictive model","Oracle"),args.legend = list(x="top",horiz=FALSE,inset=c(0,-0.1),ncol=2,cex=1.5),cex.axis=1.3,cex.names=1.2,cex.lab=1.5,mgp=c(2.8,1,0)
xx <- barplot(height, beside = TRUE,ylim = c(0, 20), names.arg = c(10,20,30,40,50,60,"gmean"))
#text(x = xx, y=height[x][], label=round(height[x],1), pos=3, col="black", font=2, cex=1.1)
#dev.off()
x
max(x,y,w,z)
for(j in c('cloudsim','convolution','fast','gol','jacobi')){
#for(i in c(24000)){
x <- apps[which(apps$app == j & apps$ite >= 1),c("speedup_cpu")]
x <- c(x,exp(mean(log(x[-1])))) #geometric mean
y <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_gpu")]
y <- c(y,exp(mean(log(y[-1])))) #geometric mean
w <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_awt")]
w <- c(w,exp(mean(log(w[-1])))) #geometric mean
z <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_oracle")]
z <- c(z,exp(mean(log(z[-1])))) #geometric mean
# create a two row matrix with x and y
height <- rbind(x,y,w,z)
#setEPS()
#postscript(paste(c(j,"_",i,"2.eps"),collapse=""))
#xlab = "# of iterations",ylab = "Speedup over single core",legend = c("CPU only","GPU only","Predictive model","Oracle"),args.legend = list(x="top",horiz=FALSE,inset=c(0,-0.1),ncol=2,cex=1.5),cex.axis=1.3,cex.names=1.2,cex.lab=1.5,mgp=c(2.8,1,0)
xx <- barplot(height, beside = TRUE,ylim = c(0, max(x,y,w,z)), names.arg = c(10,20,30,40,50,60,"gmean"))
#text(x = xx, y=height[x][], label=round(height[x],1), pos=3, col="black", font=2, cex=1.1)
#dev.off()
#}
}
xx <- barplot(height, beside = TRUE, names.arg = c(10,20,30,40,50,60,"gmean"))
xx <- barplot(height, beside = TRUE,ylim = c(0, max(x,y,w,z)+10), names.arg = c(10,20,30,40,50,60,"gmean"))
xx <- barplot(height, beside = TRUE,ylim = c(0, max(x,y,w,z)+1), names.arg = c(10,20,30,40,50,60,"gmean"))
xx <- barplot(height, beside = TRUE,ylim = c(0, max(x,y,w,z)+1), names.arg = c(10,20,30,40,50,60,"gmean"),main = j)
for(j in c('cloudsim','convolution','fast','gol','jacobi')){
#for(i in c(24000)){
x <- apps[which(apps$app == j & apps$ite >= 1),c("speedup_cpu")]
x <- c(x,exp(mean(log(x[-1])))) #geometric mean
y <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_gpu")]
y <- c(y,exp(mean(log(y[-1])))) #geometric mean
w <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_awt")]
w <- c(w,exp(mean(log(w[-1])))) #geometric mean
z <- apps[which(apps$app ==j  & apps$ite >= 1),c("speedup_oracle")]
z <- c(z,exp(mean(log(z[-1])))) #geometric mean
# create a two row matrix with x and y
height <- rbind(x,y,w,z)
#setEPS()
#postscript(paste(c(j,"_",i,"2.eps"),collapse=""))
#xlab = "# of iterations",ylab = "Speedup over single core",legend = c("CPU only","GPU only","Predictive model","Oracle"),args.legend = list(x="top",horiz=FALSE,inset=c(0,-0.1),ncol=2,cex=1.5),cex.axis=1.3,cex.names=1.2,cex.lab=1.5,mgp=c(2.8,1,0)
xx <- barplot(height, beside = TRUE,ylim = c(0, max(x,y,w,z)+1), names.arg = c(10,20,30,40,50,60,"gmean"),main = j)
#text(x = xx, y=height[x][], label=round(height[x],1), pos=3, col="black", font=2, cex=1.1)
#dev.off()
#}
}
